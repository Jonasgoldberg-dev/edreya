"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/waves.js":
/*!**********************!*\
  !*** ./src/waves.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"waves\": function() { return /* binding */ waves; }\n/* harmony export */ });\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar waves = function() {\n    var ShaderProgram = /*#__PURE__*/ function() {\n        \"use strict\";\n        function ShaderProgram(holder) {\n            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            var _this = this;\n            _classCallCheck(this, ShaderProgram);\n            options = Object.assign({\n                antialias: false,\n                depthTest: false,\n                mousemove: false,\n                autosize: true,\n                side: \"front\",\n                vertex: \"\\n                   precision highp float;\\n           \\n                   attribute vec4 a_position;\\n                   attribute vec4 a_color;\\n           \\n                   uniform float u_time;\\n                   uniform vec2 u_resolution;\\n                   uniform vec2 u_mousemove;\\n                   uniform mat4 u_projection;\\n           \\n                   varying vec4 v_color;\\n           \\n                   void main() {\\n           \\n                     gl_Position = u_projection * a_position;\\n                     gl_PointSize = (10.0 / gl_Position.w) * 100.0;\\n           \\n                     v_color = a_color;\\n           \\n                   }\",\n                fragment: \"\\n                   precision highp float;\\n           \\n                   uniform sampler2D u_texture;\\n                   uniform int u_hasTexture;\\n           \\n                   varying vec4 v_color;\\n           \\n                   void main() {\\n           \\n                     if ( u_hasTexture == 1 ) {\\n           \\n                       gl_FragColor = v_color * texture2D(u_texture, gl_PointCoord);\\n           \\n                     } else {\\n           \\n                       gl_FragColor = v_color;\\n           \\n                     }\\n           \\n                   }\",\n                uniforms: {},\n                buffers: {},\n                camera: {},\n                texture: null,\n                onUpdate: function() {},\n                onResize: function() {}\n            }, options);\n            var uniforms = Object.assign({\n                time: {\n                    type: \"float\",\n                    value: 0\n                },\n                hasTexture: {\n                    type: \"int\",\n                    value: 0\n                },\n                resolution: {\n                    type: \"vec2\",\n                    value: [\n                        0,\n                        0\n                    ]\n                },\n                mousemove: {\n                    type: \"vec2\",\n                    value: [\n                        0,\n                        0\n                    ]\n                },\n                projection: {\n                    type: \"mat4\",\n                    value: [\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ]\n                }\n            }, options.uniforms);\n            var buffers = Object.assign({\n                position: {\n                    size: 3,\n                    data: []\n                },\n                color: {\n                    size: 30,\n                    data: []\n                }\n            }, options.buffers);\n            var camera = Object.assign({\n                fov: 60,\n                near: 1,\n                far: 10000,\n                aspect: 1,\n                z: 100,\n                perspective: true\n            }, options.camera);\n            var canvas = document.createElement(\"canvas\");\n            var gl = canvas.getContext(\"webgl\", {\n                antialias: options.antialias\n            });\n            if (!gl) return false;\n            this.count = 0;\n            this.gl = gl;\n            this.canvas = canvas;\n            this.camera = camera;\n            this.holder = holder;\n            this.onUpdate = options.onUpdate;\n            this.onResize = options.onResize;\n            this.data = {};\n            holder.appendChild(canvas);\n            this.createProgram(options.vertex, options.fragment);\n            this.createBuffers(buffers);\n            this.createUniforms(uniforms);\n            this.updateBuffers();\n            this.updateUniforms();\n            this.createTexture(options.texture);\n            gl.enable(gl.BLEND);\n            gl.enable(gl.CULL_FACE);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n            gl[options.depthTest ? \"enable\" : \"disable\"](gl.DEPTH_TEST);\n            if (options.autosize) window.addEventListener(\"resize\", function(e) {\n                return _this.resize(e);\n            }, false);\n            if (options.mousemove) window.addEventListener(\"mousemove\", function(e) {\n                return _this.mousemove(e);\n            }, false);\n            this.resize();\n            this.update = this.update.bind(this);\n            this.time = {\n                start: performance.now(),\n                old: performance.now()\n            };\n            this.update();\n        }\n        _createClass(ShaderProgram, [\n            {\n                key: \"mousemove\",\n                value: function mousemove(e) {\n                    var x = e.pageX / this.width * 2 - 1;\n                    var y = e.pageY / this.height * 2 - 1;\n                    this.uniforms.mousemove = [\n                        x,\n                        y\n                    ];\n                }\n            },\n            {\n                key: \"resize\",\n                value: function resize(e) {\n                    var holder = this.holder;\n                    var canvas = this.canvas;\n                    var gl = this.gl;\n                    var width = this.width = holder.offsetWidth;\n                    var height = this.height = holder.offsetHeight;\n                    var aspect = this.aspect = width / height;\n                    var dpi = devicePixelRatio;\n                    canvas.width = width * dpi;\n                    canvas.height = height * dpi;\n                    canvas.style.width = width + \"px\";\n                    canvas.style.height = height + \"px\";\n                    gl.viewport(0, 0, width * dpi, height * dpi);\n                    gl.clearColor(0, 0, 0, 0);\n                    this.uniforms.resolution = [\n                        width,\n                        height\n                    ];\n                    this.uniforms.projection = this.setProjection(aspect);\n                    this.onResize(width, height, dpi);\n                }\n            },\n            {\n                key: \"setProjection\",\n                value: function setProjection(aspect) {\n                    var camera = this.camera;\n                    if (camera.perspective) {\n                        camera.aspect = aspect;\n                        var fovRad = camera.fov * (Math.PI / 180);\n                        var f = Math.tan(Math.PI * 0.5 - 0.5 * fovRad);\n                        var rangeInv = 1.0 / (camera.near - camera.far);\n                        var matrix = [\n                            f / camera.aspect,\n                            0,\n                            0,\n                            0,\n                            0,\n                            f,\n                            0,\n                            0,\n                            0,\n                            0,\n                            (camera.near + camera.far) * rangeInv,\n                            -1,\n                            0,\n                            0,\n                            camera.near * camera.far * rangeInv * 2,\n                            0, \n                        ];\n                        matrix[14] += camera.z;\n                        matrix[15] += camera.z;\n                        return matrix;\n                    } else {\n                        return [\n                            2 / this.width,\n                            0,\n                            0,\n                            0,\n                            0,\n                            -2 / this.height,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            -1,\n                            1,\n                            0,\n                            1, \n                        ];\n                    }\n                }\n            },\n            {\n                key: \"createShader\",\n                value: function createShader(type, source) {\n                    var gl = this.gl;\n                    var shader = gl.createShader(type);\n                    gl.shaderSource(shader, source);\n                    gl.compileShader(shader);\n                    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                        return shader;\n                    } else {\n                        console.log(gl.getShaderInfoLog(shader));\n                        gl.deleteShader(shader);\n                    }\n                }\n            },\n            {\n                key: \"createProgram\",\n                value: function createProgram(vertex, fragment) {\n                    var gl = this.gl;\n                    var vertexShader = this.createShader(gl.VERTEX_SHADER, vertex);\n                    var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragment);\n                    var program = gl.createProgram();\n                    gl.attachShader(program, vertexShader);\n                    gl.attachShader(program, fragmentShader);\n                    gl.linkProgram(program);\n                    if (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                        gl.useProgram(program);\n                        this.program = program;\n                    } else {\n                        console.log(gl.getProgramInfoLog(program));\n                        gl.deleteProgram(program);\n                    }\n                }\n            },\n            {\n                key: \"createUniforms\",\n                value: function createUniforms(data) {\n                    var _this = this;\n                    var gl = this.gl;\n                    var uniforms = this.data.uniforms = data;\n                    var values = this.uniforms = {};\n                    Object.keys(uniforms).forEach(function(name) {\n                        var _this1 = _this;\n                        var uniform = uniforms[name];\n                        uniform.location = gl.getUniformLocation(_this.program, \"u_\" + name);\n                        Object.defineProperty(values, name, {\n                            set: function(value) {\n                                uniforms[name].value = value;\n                                _this1.setUniform(name, value);\n                            },\n                            get: function() {\n                                return uniforms[name].value;\n                            }\n                        });\n                    });\n                }\n            },\n            {\n                key: \"setUniform\",\n                value: function setUniform(name, value) {\n                    var gl = this.gl;\n                    var uniform = this.data.uniforms[name];\n                    uniform.value = value;\n                    switch(uniform.type){\n                        case \"int\":\n                            {\n                                gl.uniform1i(uniform.location, value);\n                                break;\n                            }\n                        case \"float\":\n                            {\n                                gl.uniform1f(uniform.location, value);\n                                break;\n                            }\n                        case \"vec2\":\n                            {\n                                var _gl;\n                                (_gl = gl).uniform2f.apply(_gl, [\n                                    uniform.location\n                                ].concat(_toConsumableArray(value)));\n                                break;\n                            }\n                        case \"vec3\":\n                            {\n                                var _gl1;\n                                (_gl1 = gl).uniform3f.apply(_gl1, [\n                                    uniform.location\n                                ].concat(_toConsumableArray(value)));\n                                break;\n                            }\n                        case \"vec4\":\n                            {\n                                var _gl2;\n                                (_gl2 = gl).uniform4f.apply(_gl2, [\n                                    uniform.location\n                                ].concat(_toConsumableArray(value)));\n                                break;\n                            }\n                        case \"mat2\":\n                            {\n                                gl.uniformMatrix2fv(uniform.location, false, value);\n                                break;\n                            }\n                        case \"mat3\":\n                            {\n                                gl.uniformMatrix3fv(uniform.location, false, value);\n                                break;\n                            }\n                        case \"mat4\":\n                            {\n                                gl.uniformMatrix4fv(uniform.location, false, value);\n                                break;\n                            }\n                    }\n                // ivec2       : uniform2i,\n                // ivec3       : uniform3i,\n                // ivec4       : uniform4i,\n                // sampler2D   : uniform1i,\n                // samplerCube : uniform1i,\n                // bool        : uniform1i,\n                // bvec2       : uniform2i,\n                // bvec3       : uniform3i,\n                // bvec4       : uniform4i,\n                }\n            },\n            {\n                key: \"updateUniforms\",\n                value: function updateUniforms() {\n                    var _this = this;\n                    var gl = this.gl;\n                    var uniforms = this.data.uniforms;\n                    Object.keys(uniforms).forEach(function(name) {\n                        var uniform = uniforms[name];\n                        _this.uniforms[name] = uniform.value;\n                    });\n                }\n            },\n            {\n                key: \"createBuffers\",\n                value: function createBuffers(data1) {\n                    var _this = this;\n                    var gl = this.gl;\n                    var buffers = this.data.buffers = data1;\n                    var values = this.buffers = {};\n                    Object.keys(buffers).forEach(function(name) {\n                        var _this2 = _this;\n                        var buffer = buffers[name];\n                        buffer.buffer = _this.createBuffer(\"a_\" + name, buffer.size);\n                        Object.defineProperty(values, name, {\n                            set: function(data) {\n                                buffers[name].data = data;\n                                _this2.setBuffer(name, data);\n                                if (name == \"position\") _this2.count = buffers.position.data.length / 3;\n                            },\n                            get: function() {\n                                return buffers[name].data;\n                            }\n                        });\n                    });\n                }\n            },\n            {\n                key: \"createBuffer\",\n                value: function createBuffer(name, size) {\n                    var gl = this.gl;\n                    var program = this.program;\n                    var index = gl.getAttribLocation(program, name);\n                    var buffer = gl.createBuffer();\n                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n                    gl.enableVertexAttribArray(index);\n                    gl.vertexAttribPointer(index, size, gl.FLOAT, false, 0, 0);\n                    return buffer;\n                }\n            },\n            {\n                key: \"setBuffer\",\n                value: function setBuffer(name, data) {\n                    var gl = this.gl;\n                    var buffers = this.data.buffers;\n                    if (name == null && !gl.bindBuffer(gl.ARRAY_BUFFER, null)) return;\n                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers[name].buffer);\n                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\n                }\n            },\n            {\n                key: \"updateBuffers\",\n                value: function updateBuffers() {\n                    var gl = this.gl;\n                    var buffers = this.buffers;\n                    Object.keys(buffers).forEach(function(name) {\n                        return buffers[name] = buffer.data;\n                    });\n                    this.setBuffer(null);\n                }\n            },\n            {\n                key: \"createTexture\",\n                value: function createTexture(src) {\n                    var gl = this.gl;\n                    var texture = gl.createTexture();\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([\n                        0,\n                        0,\n                        0,\n                        0\n                    ]));\n                    this.texture = texture;\n                    if (src) {\n                        this.uniforms.hasTexture = 1;\n                        this.loadTexture(src);\n                    }\n                }\n            },\n            {\n                key: \"loadTexture\",\n                value: function loadTexture(src) {\n                    var gl = this.gl;\n                    var texture = this.texture;\n                    var textureImage = new Image();\n                    textureImage.onload = function() {\n                        gl.bindTexture(gl.TEXTURE_2D, texture);\n                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    };\n                    textureImage.src = src;\n                }\n            },\n            {\n                key: \"update\",\n                value: function update() {\n                    var gl = this.gl;\n                    var now = performance.now();\n                    var elapsed = (now - this.time.start) / 5000;\n                    var delta = now - this.time.old;\n                    this.time.old = now;\n                    this.uniforms.time = elapsed;\n                    if (this.count > 0) {\n                        gl.clear(gl.COLORBUFFERBIT);\n                        gl.drawArrays(gl.POINTS, 0, this.count);\n                    }\n                    this.onUpdate(delta);\n                    requestAnimationFrame(this.update);\n                }\n            }\n        ]);\n        return ShaderProgram;\n    }();\n    var pointSize = 2.5;\n    var waves = new ShaderProgram(document.querySelector(\".waves\"), {\n        texture: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAb1BMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8v0wLRAAAAJHRSTlMAC/goGvDhmwcExrVjWzrm29TRqqSKenRXVklANSIUE8mRkGpv+HOfAAABCElEQVQ4y4VT13LDMAwLrUHteO+R9f/fWMfO6dLaPeKVEECRxOULWsEGpS9nULDwia2Y+ALqUNbAWeg775zv+sA4/FFRMxt8U2FZFCVWjR/YrH4/H9sarclSKdPMWKzb8VsEeHB3m0shkhVCyNzeXeAQ9Xl4opEieX2QCGnwGbj6GMyjw9t1K0fK9YZunPXeAGsfJtYjwzxaBnozGGorYz0ypK2HzQSYx1y8DgSRo2ewOiyh2QWOEk1Y9OrQV0a8TiBM1a8eMHWYnRMy7CZ4t1CmyRkhSUvP3gRXyHOCLBxNoC3IJv//ZrJ/kxxUHPUB+6jJZZHrpg6GOjnqaOmzp4NDR48OLxn/H27SRQ08S0ZJAAAAAElFTkSuQmCC\",\n        uniforms: {\n            size: {\n                type: \"float\",\n                value: pointSize\n            },\n            field: {\n                type: \"vec3\",\n                value: [\n                    0,\n                    0,\n                    0\n                ]\n            },\n            speed: {\n                type: \"float\",\n                value: 5\n            }\n        },\n        vertex: \"\\n               #define M_PI 3.1415926535897932384626433832795\\n           \\n               precision highp float;\\n           \\n               attribute vec4 a_position;\\n               attribute vec4 a_color;\\n           \\n               uniform float u_time;\\n               uniform float u_size;\\n               uniform float u_speed;\\n               uniform vec3 u_field;\\n               uniform mat4 u_projection;\\n           \\n               varying vec4 v_color;\\n           \\n               void main() {\\n           \\n                 vec3 pos = a_position.xyz;\\n           \\n                 pos.y += (\\n                   cos(pos.x / u_field.x * M_PI * 8.0 + u_time * u_speed) +\\n                   sin(pos.z / u_field.z * M_PI * 8.0 + u_time * u_speed)\\n                 ) * u_field.y;\\n           \\n                 gl_Position = u_projection * vec4( pos.xyz, a_position.w );\\n                 gl_PointSize = ( u_size / gl_Position.w ) * 100.0;\\n           \\n                 v_color = a_color;\\n           \\n               }\",\n        fragment: \"\\n               precision highp float;\\n           \\n               uniform sampler2D u_texture;\\n           \\n               varying vec4 v_color;\\n           \\n               void main() {\\n           \\n                 gl_FragColor = v_color * texture2D(u_texture, gl_PointCoord);\\n           \\n               }\",\n        onResize: function onResize(w, h, dpi) {\n            var position = [], color = [];\n            var width = 400 * (w / h);\n            var depth = 400;\n            var height = 3;\n            var distance = 5;\n            for(var x = 0; x < width; x += distance){\n                for(var z = 0; z < depth; z += distance){\n                    position.push(-width / 2 + x, -30, -depth / 2 + z);\n                    color.push(0, 1 - x / width * 1, 0.5 + x / width * 0.5, z / depth);\n                }\n            }\n            this.uniforms.field = [\n                width,\n                height,\n                depth\n            ];\n            this.buffers.position = position;\n            this.buffers.color = color;\n            this.uniforms.size = h / 400 * pointSize * dpi;\n        }\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcsQ0FBQyxHQUFHNUksQ0FBQyxDQUFDLENBQUM7b0JBQ25ETCxLQUFLLENBQUNtSixJQUFJLENBQ1IsQ0FBQyxFQUNELENBQUMsR0FBRyxDQUFFLEdBQUc1RyxLQUFLLEdBQUksQ0FBQyxFQUNuQixHQUFHLEdBQUcsQ0FBRSxHQUFHQSxLQUFLLEdBQUksR0FBRyxFQUN2QmxDLENBQUMsR0FBRzRJLEtBQUssQ0FDVixDQUFDO2lCQUNIO2FBQ0Y7WUFFRCxJQUFJLENBQUNoSyxRQUFRLENBQUM0SixLQUFLLEdBQUc7Z0JBQUN0RyxLQUFLO2dCQUFFRyxNQUFNO2dCQUFFdUcsS0FBSzthQUFDLENBQUM7WUFFN0MsSUFBSSxDQUFDL0osT0FBTyxDQUFDVyxRQUFRLEdBQUdBLFFBQVEsQ0FBQztZQUNqQyxJQUFJLENBQUNYLE9BQU8sQ0FBQ2MsS0FBSyxHQUFHQSxLQUFLLENBQUM7WUFFM0IsSUFBSSxDQUFDZixRQUFRLENBQUNhLElBQUksR0FBRyxDQUFFLEdBQUcsR0FBRyxHQUFJNkksU0FBUyxHQUFHOUYsR0FBRyxDQUFDO1NBQ2xEO0tBQ0YsQ0FBQztDQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3dhdmVzLmpzPzcwN2MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHdhdmVzID0gKCkgPT4ge1xyXG4gIGNsYXNzIFNoYWRlclByb2dyYW0ge1xyXG4gICAgY29uc3RydWN0b3IoaG9sZGVyLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcclxuICAgICAgICAgIGRlcHRoVGVzdDogZmFsc2UsXHJcbiAgICAgICAgICBtb3VzZW1vdmU6IGZhbHNlLFxyXG4gICAgICAgICAgYXV0b3NpemU6IHRydWUsXHJcbiAgICAgICAgICBzaWRlOiBcImZyb250XCIsXHJcbiAgICAgICAgICB2ZXJ0ZXg6IGBcclxuICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X3RpbWU7XHJcbiAgICAgICAgICAgICAgICAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIHVfbW91c2Vtb3ZlO1xyXG4gICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfcHJvamVjdGlvbiAqIGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgIGdsX1BvaW50U2l6ZSA9ICgxMC4wIC8gZ2xfUG9zaXRpb24udykgKiAxMDAuMDtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgdl9jb2xvciA9IGFfY29sb3I7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICB9YCxcclxuICAgICAgICAgIGZyYWdtZW50OiBgXHJcbiAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICB1bmlmb3JtIGludCB1X2hhc1RleHR1cmU7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgaWYgKCB1X2hhc1RleHR1cmUgPT0gMSApIHtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yICogdGV4dHVyZTJEKHVfdGV4dHVyZSwgZ2xfUG9pbnRDb29yZCk7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgfWAsXHJcbiAgICAgICAgICB1bmlmb3Jtczoge30sXHJcbiAgICAgICAgICBidWZmZXJzOiB7fSxcclxuICAgICAgICAgIGNhbWVyYToge30sXHJcbiAgICAgICAgICB0ZXh0dXJlOiBudWxsLFxyXG4gICAgICAgICAgb25VcGRhdGU6ICgpID0+IHt9LFxyXG4gICAgICAgICAgb25SZXNpemU6ICgpID0+IHt9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3B0aW9uc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgdW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHRpbWU6IHsgdHlwZTogXCJmbG9hdFwiLCB2YWx1ZTogMCB9LFxyXG4gICAgICAgICAgaGFzVGV4dHVyZTogeyB0eXBlOiBcImludFwiLCB2YWx1ZTogMCB9LFxyXG4gICAgICAgICAgcmVzb2x1dGlvbjogeyB0eXBlOiBcInZlYzJcIiwgdmFsdWU6IFswLCAwXSB9LFxyXG4gICAgICAgICAgbW91c2Vtb3ZlOiB7IHR5cGU6IFwidmVjMlwiLCB2YWx1ZTogWzAsIDBdIH0sXHJcbiAgICAgICAgICBwcm9qZWN0aW9uOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwibWF0NFwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9wdGlvbnMudW5pZm9ybXNcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBPYmplY3QuYXNzaWduKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHBvc2l0aW9uOiB7IHNpemU6IDMsIGRhdGE6IFtdIH0sXHJcbiAgICAgICAgICBjb2xvcjogeyBzaXplOiAzMCwgZGF0YTogW10gfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9wdGlvbnMuYnVmZmVyc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgY2FtZXJhID0gT2JqZWN0LmFzc2lnbihcclxuICAgICAgICB7XHJcbiAgICAgICAgICBmb3Y6IDYwLFxyXG4gICAgICAgICAgbmVhcjogMSxcclxuICAgICAgICAgIGZhcjogMTAwMDAsXHJcbiAgICAgICAgICBhc3BlY3Q6IDEsXHJcbiAgICAgICAgICB6OiAxMDAsXHJcbiAgICAgICAgICBwZXJzcGVjdGl2ZTogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9wdGlvbnMuY2FtZXJhXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgeyBhbnRpYWxpYXM6IG9wdGlvbnMuYW50aWFsaWFzIH0pO1xyXG5cclxuICAgICAgaWYgKCFnbCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XHJcbiAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICB0aGlzLmhvbGRlciA9IGhvbGRlcjtcclxuICAgICAgdGhpcy5vblVwZGF0ZSA9IG9wdGlvbnMub25VcGRhdGU7XHJcbiAgICAgIHRoaXMub25SZXNpemUgPSBvcHRpb25zLm9uUmVzaXplO1xyXG4gICAgICB0aGlzLmRhdGEgPSB7fTtcclxuXHJcbiAgICAgIGhvbGRlci5hcHBlbmRDaGlsZChjYW52YXMpO1xyXG5cclxuICAgICAgdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMudmVydGV4LCBvcHRpb25zLmZyYWdtZW50KTtcclxuXHJcbiAgICAgIHRoaXMuY3JlYXRlQnVmZmVycyhidWZmZXJzKTtcclxuICAgICAgdGhpcy5jcmVhdGVVbmlmb3Jtcyh1bmlmb3Jtcyk7XHJcblxyXG4gICAgICB0aGlzLnVwZGF0ZUJ1ZmZlcnMoKTtcclxuICAgICAgdGhpcy51cGRhdGVVbmlmb3JtcygpO1xyXG5cclxuICAgICAgdGhpcy5jcmVhdGVUZXh0dXJlKG9wdGlvbnMudGV4dHVyZSk7XHJcblxyXG4gICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcclxuICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcclxuICAgICAgZ2xbb3B0aW9ucy5kZXB0aFRlc3QgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgaWYgKG9wdGlvbnMuYXV0b3NpemUpXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKGUpID0+IHRoaXMucmVzaXplKGUpLCBmYWxzZSk7XHJcbiAgICAgIGlmIChvcHRpb25zLm1vdXNlbW92ZSlcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZSkgPT4gdGhpcy5tb3VzZW1vdmUoZSksIGZhbHNlKTtcclxuXHJcbiAgICAgIHRoaXMucmVzaXplKCk7XHJcblxyXG4gICAgICB0aGlzLnVwZGF0ZSA9IHRoaXMudXBkYXRlLmJpbmQodGhpcyk7XHJcbiAgICAgIHRoaXMudGltZSA9IHsgc3RhcnQ6IHBlcmZvcm1hbmNlLm5vdygpLCBvbGQ6IHBlcmZvcm1hbmNlLm5vdygpIH07XHJcbiAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbW91c2Vtb3ZlKGUpIHtcclxuICAgICAgbGV0IHggPSAoZS5wYWdlWCAvIHRoaXMud2lkdGgpICogMiAtIDE7XHJcbiAgICAgIGxldCB5ID0gKGUucGFnZVkgLyB0aGlzLmhlaWdodCkgKiAyIC0gMTtcclxuXHJcbiAgICAgIHRoaXMudW5pZm9ybXMubW91c2Vtb3ZlID0gW3gsIHldO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc2l6ZShlKSB7XHJcbiAgICAgIGNvbnN0IGhvbGRlciA9IHRoaXMuaG9sZGVyO1xyXG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgY29uc3Qgd2lkdGggPSAodGhpcy53aWR0aCA9IGhvbGRlci5vZmZzZXRXaWR0aCk7XHJcbiAgICAgIGNvbnN0IGhlaWdodCA9ICh0aGlzLmhlaWdodCA9IGhvbGRlci5vZmZzZXRIZWlnaHQpO1xyXG4gICAgICBjb25zdCBhc3BlY3QgPSAodGhpcy5hc3BlY3QgPSB3aWR0aCAvIGhlaWdodCk7XHJcbiAgICAgIGNvbnN0IGRwaSA9IGRldmljZVBpeGVsUmF0aW87XHJcblxyXG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIGRwaTtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwaTtcclxuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XHJcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XHJcblxyXG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCAqIGRwaSwgaGVpZ2h0ICogZHBpKTtcclxuICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcclxuXHJcbiAgICAgIHRoaXMudW5pZm9ybXMucmVzb2x1dGlvbiA9IFt3aWR0aCwgaGVpZ2h0XTtcclxuICAgICAgdGhpcy51bmlmb3Jtcy5wcm9qZWN0aW9uID0gdGhpcy5zZXRQcm9qZWN0aW9uKGFzcGVjdCk7XHJcblxyXG4gICAgICB0aGlzLm9uUmVzaXplKHdpZHRoLCBoZWlnaHQsIGRwaSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UHJvamVjdGlvbihhc3BlY3QpIHtcclxuICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XHJcblxyXG4gICAgICBpZiAoY2FtZXJhLnBlcnNwZWN0aXZlKSB7XHJcbiAgICAgICAgY2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcclxuXHJcbiAgICAgICAgY29uc3QgZm92UmFkID0gY2FtZXJhLmZvdiAqIChNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICBjb25zdCBmID0gTWF0aC50YW4oTWF0aC5QSSAqIDAuNSAtIDAuNSAqIGZvdlJhZCk7XHJcbiAgICAgICAgY29uc3QgcmFuZ2VJbnYgPSAxLjAgLyAoY2FtZXJhLm5lYXIgLSBjYW1lcmEuZmFyKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWF0cml4ID0gW1xyXG4gICAgICAgICAgZiAvIGNhbWVyYS5hc3BlY3QsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgZixcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAoY2FtZXJhLm5lYXIgKyBjYW1lcmEuZmFyKSAqIHJhbmdlSW52LFxyXG4gICAgICAgICAgLTEsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIGNhbWVyYS5uZWFyICogY2FtZXJhLmZhciAqIHJhbmdlSW52ICogMixcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgbWF0cml4WzE0XSArPSBjYW1lcmEuejtcclxuICAgICAgICBtYXRyaXhbMTVdICs9IGNhbWVyYS56O1xyXG5cclxuICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAyIC8gdGhpcy53aWR0aCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAtMiAvIHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDEsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgLTEsXHJcbiAgICAgICAgICAxLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDEsXHJcbiAgICAgICAgXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVNoYWRlcih0eXBlLCBzb3VyY2UpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcblxyXG4gICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xyXG4gICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcblxyXG4gICAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xyXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXgsIGZyYWdtZW50KSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleCk7XHJcbiAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudCk7XHJcblxyXG4gICAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XHJcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG5cclxuICAgICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcclxuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlVW5pZm9ybXMoZGF0YSkge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IHVuaWZvcm1zID0gKHRoaXMuZGF0YS51bmlmb3JtcyA9IGRhdGEpO1xyXG4gICAgICBjb25zdCB2YWx1ZXMgPSAodGhpcy51bmlmb3JtcyA9IHt9KTtcclxuXHJcbiAgICAgIE9iamVjdC5rZXlzKHVuaWZvcm1zKS5mb3JFYWNoKChuYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdW5pZm9ybSA9IHVuaWZvcm1zW25hbWVdO1xyXG5cclxuICAgICAgICB1bmlmb3JtLmxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X1wiICsgbmFtZSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsIG5hbWUsIHtcclxuICAgICAgICAgIHNldDogKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zW25hbWVdLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybShuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZ2V0OiAoKSA9PiB1bmlmb3Jtc1tuYW1lXS52YWx1ZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VW5pZm9ybShuYW1lLCB2YWx1ZSkge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IHVuaWZvcm0gPSB0aGlzLmRhdGEudW5pZm9ybXNbbmFtZV07XHJcblxyXG4gICAgICB1bmlmb3JtLnZhbHVlID0gdmFsdWU7XHJcblxyXG4gICAgICBzd2l0Y2ggKHVuaWZvcm0udHlwZSkge1xyXG4gICAgICAgIGNhc2UgXCJpbnRcIjoge1xyXG4gICAgICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm0ubG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiZmxvYXRcIjoge1xyXG4gICAgICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm0ubG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwidmVjMlwiOiB7XHJcbiAgICAgICAgICBnbC51bmlmb3JtMmYodW5pZm9ybS5sb2NhdGlvbiwgLi4udmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJ2ZWMzXCI6IHtcclxuICAgICAgICAgIGdsLnVuaWZvcm0zZih1bmlmb3JtLmxvY2F0aW9uLCAuLi52YWx1ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcInZlYzRcIjoge1xyXG4gICAgICAgICAgZ2wudW5pZm9ybTRmKHVuaWZvcm0ubG9jYXRpb24sIC4uLnZhbHVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwibWF0MlwiOiB7XHJcbiAgICAgICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KHVuaWZvcm0ubG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIm1hdDNcIjoge1xyXG4gICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1bmlmb3JtLmxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJtYXQ0XCI6IHtcclxuICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybS5sb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaXZlYzIgICAgICAgOiB1bmlmb3JtMmksXHJcbiAgICAgIC8vIGl2ZWMzICAgICAgIDogdW5pZm9ybTNpLFxyXG4gICAgICAvLyBpdmVjNCAgICAgICA6IHVuaWZvcm00aSxcclxuICAgICAgLy8gc2FtcGxlcjJEICAgOiB1bmlmb3JtMWksXHJcbiAgICAgIC8vIHNhbXBsZXJDdWJlIDogdW5pZm9ybTFpLFxyXG4gICAgICAvLyBib29sICAgICAgICA6IHVuaWZvcm0xaSxcclxuICAgICAgLy8gYnZlYzIgICAgICAgOiB1bmlmb3JtMmksXHJcbiAgICAgIC8vIGJ2ZWMzICAgICAgIDogdW5pZm9ybTNpLFxyXG4gICAgICAvLyBidmVjNCAgICAgICA6IHVuaWZvcm00aSxcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVVbmlmb3JtcygpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMuZGF0YS51bmlmb3JtcztcclxuXHJcbiAgICAgIE9iamVjdC5rZXlzKHVuaWZvcm1zKS5mb3JFYWNoKChuYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdW5pZm9ybSA9IHVuaWZvcm1zW25hbWVdO1xyXG5cclxuICAgICAgICB0aGlzLnVuaWZvcm1zW25hbWVdID0gdW5pZm9ybS52YWx1ZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQnVmZmVycyhkYXRhKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgY29uc3QgYnVmZmVycyA9ICh0aGlzLmRhdGEuYnVmZmVycyA9IGRhdGEpO1xyXG4gICAgICBjb25zdCB2YWx1ZXMgPSAodGhpcy5idWZmZXJzID0ge30pO1xyXG5cclxuICAgICAgT2JqZWN0LmtleXMoYnVmZmVycykuZm9yRWFjaCgobmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbbmFtZV07XHJcblxyXG4gICAgICAgIGJ1ZmZlci5idWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcihcImFfXCIgKyBuYW1lLCBidWZmZXIuc2l6ZSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsIG5hbWUsIHtcclxuICAgICAgICAgIHNldDogKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgYnVmZmVyc1tuYW1lXS5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIobmFtZSwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcInBvc2l0aW9uXCIpXHJcbiAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IGJ1ZmZlcnMucG9zaXRpb24uZGF0YS5sZW5ndGggLyAzO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGdldDogKCkgPT4gYnVmZmVyc1tuYW1lXS5kYXRhLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVCdWZmZXIobmFtZSwgc2l6ZSkge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLnByb2dyYW07XHJcblxyXG4gICAgICBjb25zdCBpbmRleCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xyXG4gICAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIHNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcblxyXG4gICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEJ1ZmZlcihuYW1lLCBkYXRhKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgY29uc3QgYnVmZmVycyA9IHRoaXMuZGF0YS5idWZmZXJzO1xyXG5cclxuICAgICAgaWYgKG5hbWUgPT0gbnVsbCAmJiAhZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpKSByZXR1cm47XHJcblxyXG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyc1tuYW1lXS5idWZmZXIpO1xyXG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShkYXRhKSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUJ1ZmZlcnMoKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgY29uc3QgYnVmZmVycyA9IHRoaXMuYnVmZmVycztcclxuXHJcbiAgICAgIE9iamVjdC5rZXlzKGJ1ZmZlcnMpLmZvckVhY2goKG5hbWUpID0+IChidWZmZXJzW25hbWVdID0gYnVmZmVyLmRhdGEpKTtcclxuXHJcbiAgICAgIHRoaXMuc2V0QnVmZmVyKG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVRleHR1cmUoc3JjKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG4gICAgICBnbC50ZXhJbWFnZTJEKFxyXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXHJcbiAgICAgICAgMCxcclxuICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgMSxcclxuICAgICAgICAwLFxyXG4gICAgICAgIGdsLlJHQkEsXHJcbiAgICAgICAgZ2wuVU5TSUdORURfQllURSxcclxuICAgICAgICBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMF0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG5cclxuICAgICAgaWYgKHNyYykge1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMuaGFzVGV4dHVyZSA9IDE7XHJcbiAgICAgICAgdGhpcy5sb2FkVGV4dHVyZShzcmMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZFRleHR1cmUoc3JjKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcclxuXHJcbiAgICAgIGNvbnN0IHRleHR1cmVJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cclxuICAgICAgdGV4dHVyZUltYWdlLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuXHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChcclxuICAgICAgICAgIGdsLlRFWFRVUkVfMkQsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgZ2wuUkdCQSxcclxuICAgICAgICAgIGdsLlJHQkEsXHJcbiAgICAgICAgICBnbC5VTlNJR05FRF9CWVRFLFxyXG4gICAgICAgICAgdGV4dHVyZUltYWdlXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XHJcblxyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGV4dHVyZUltYWdlLnNyYyA9IHNyYztcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICBjb25zdCBlbGFwc2VkID0gKG5vdyAtIHRoaXMudGltZS5zdGFydCkgLyA1MDAwO1xyXG4gICAgICBjb25zdCBkZWx0YSA9IG5vdyAtIHRoaXMudGltZS5vbGQ7XHJcbiAgICAgIHRoaXMudGltZS5vbGQgPSBub3c7XHJcblxyXG4gICAgICB0aGlzLnVuaWZvcm1zLnRpbWUgPSBlbGFwc2VkO1xyXG5cclxuICAgICAgaWYgKHRoaXMuY291bnQgPiAwKSB7XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JCVUZGRVJCSVQpO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCB0aGlzLmNvdW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5vblVwZGF0ZShkZWx0YSk7XHJcblxyXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcG9pbnRTaXplID0gMi41O1xyXG5cclxuICBjb25zdCB3YXZlcyA9IG5ldyBTaGFkZXJQcm9ncmFtKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIud2F2ZXNcIiksIHtcclxuICAgIHRleHR1cmU6XHJcbiAgICAgIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQWIxQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy84djB3TFJBQUFBSkhSU1RsTUFDL2dvR3ZEaG13Y0V4clZqV3pybTI5VFJxcVNLZW5SWFZrbEFOU0lVRThtUmtHcHYrSE9mQUFBQkNFbEVRVlE0eTRWVDEzTERNQXdMclVIdGVPK1I5Zi9mV01mTzZkTGFQZUtWRUVDUnhPVUxXc0VHcFM5blVMRHdpYTJZK0FMcVVOYkFXZWc3NzV6ditzQTQvRkZSTXh0OFUyRlpGQ1ZXalIvWXJINC9IOXNhcmNsU0tkUE1XS3piOFZzRWVIQjNtMHNoa2hWQ3lOemVYZUFROVhsNG9wRWllWDJRQ0dud0diajZHTXlqdzl0MUswZks5WVp1blBYZUFHc2ZKdFlqd3p4YUJub3pHR29yWXoweXBLMkh6UVNZeDF5OERnU1JvMmV3T2l5aDJRV09FazFZOU9yUVYwYThUaUJNMWE4ZU1IV1luUk15N0NaNHQxQ215UmtoU1V2UDNnUlh5SE9DTEJ4Tm9DM0lKdi8vWnJKL2t4eFVIUFVCKzZqSlpaSHJwZzZHT2pucWFPbXpwNE5EUjQ4T0x4bi9IMjdTUlEwOFMwWkpBQUFBQUVsRlRrU3VRbUNDXCIsXHJcbiAgICB1bmlmb3Jtczoge1xyXG4gICAgICBzaXplOiB7IHR5cGU6IFwiZmxvYXRcIiwgdmFsdWU6IHBvaW50U2l6ZSB9LFxyXG4gICAgICBmaWVsZDogeyB0eXBlOiBcInZlYzNcIiwgdmFsdWU6IFswLCAwLCAwXSB9LFxyXG4gICAgICBzcGVlZDogeyB0eXBlOiBcImZsb2F0XCIsIHZhbHVlOiA1IH0sXHJcbiAgICB9LFxyXG4gICAgdmVydGV4OiBgXHJcbiAgICAgICAgICAgICAgICNkZWZpbmUgTV9QSSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTVcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVfdGltZTtcclxuICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X3NpemU7XHJcbiAgICAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdV9zcGVlZDtcclxuICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWMzIHVfZmllbGQ7XHJcbiAgICAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1X3Byb2plY3Rpb247XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgdmVjMyBwb3MgPSBhX3Bvc2l0aW9uLnh5ejtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICBwb3MueSArPSAoXHJcbiAgICAgICAgICAgICAgICAgICBjb3MocG9zLnggLyB1X2ZpZWxkLnggKiBNX1BJICogOC4wICsgdV90aW1lICogdV9zcGVlZCkgK1xyXG4gICAgICAgICAgICAgICAgICAgc2luKHBvcy56IC8gdV9maWVsZC56ICogTV9QSSAqIDguMCArIHVfdGltZSAqIHVfc3BlZWQpXHJcbiAgICAgICAgICAgICAgICAgKSAqIHVfZmllbGQueTtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfcHJvamVjdGlvbiAqIHZlYzQoIHBvcy54eXosIGFfcG9zaXRpb24udyApO1xyXG4gICAgICAgICAgICAgICAgIGdsX1BvaW50U2l6ZSA9ICggdV9zaXplIC8gZ2xfUG9zaXRpb24udyApICogMTAwLjA7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgdl9jb2xvciA9IGFfY29sb3I7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIH1gLFxyXG4gICAgZnJhZ21lbnQ6IGBcclxuICAgICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvciAqIHRleHR1cmUyRCh1X3RleHR1cmUsIGdsX1BvaW50Q29vcmQpO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICB9YCxcclxuICAgIG9uUmVzaXplKHcsIGgsIGRwaSkge1xyXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IFtdLFxyXG4gICAgICAgIGNvbG9yID0gW107XHJcblxyXG4gICAgICBjb25zdCB3aWR0aCA9IDQwMCAqICh3IC8gaCk7XHJcbiAgICAgIGNvbnN0IGRlcHRoID0gNDAwO1xyXG4gICAgICBjb25zdCBoZWlnaHQgPSAzO1xyXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IDU7XHJcblxyXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4ICs9IGRpc3RhbmNlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeiArPSBkaXN0YW5jZSkge1xyXG4gICAgICAgICAgcG9zaXRpb24ucHVzaCgtd2lkdGggLyAyICsgeCwgLTMwLCAtZGVwdGggLyAyICsgeik7XHJcbiAgICAgICAgICBjb2xvci5wdXNoKFxyXG4gICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAxIC0gKHggLyB3aWR0aCkgKiAxLFxyXG4gICAgICAgICAgICAwLjUgKyAoeCAvIHdpZHRoKSAqIDAuNSxcclxuICAgICAgICAgICAgeiAvIGRlcHRoXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy51bmlmb3Jtcy5maWVsZCA9IFt3aWR0aCwgaGVpZ2h0LCBkZXB0aF07XHJcblxyXG4gICAgICB0aGlzLmJ1ZmZlcnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgdGhpcy5idWZmZXJzLmNvbG9yID0gY29sb3I7XHJcblxyXG4gICAgICB0aGlzLnVuaWZvcm1zLnNpemUgPSAoaCAvIDQwMCkgKiBwb2ludFNpemUgKiBkcGk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG59O1xyXG4iXSwibmFtZXMiOlsid2F2ZXMiLCJTaGFkZXJQcm9ncmFtIiwiaG9sZGVyIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsImFudGlhbGlhcyIsImRlcHRoVGVzdCIsIm1vdXNlbW92ZSIsImF1dG9zaXplIiwic2lkZSIsInZlcnRleCIsImZyYWdtZW50IiwidW5pZm9ybXMiLCJidWZmZXJzIiwiY2FtZXJhIiwidGV4dHVyZSIsIm9uVXBkYXRlIiwib25SZXNpemUiLCJ0aW1lIiwidHlwZSIsInZhbHVlIiwiaGFzVGV4dHVyZSIsInJlc29sdXRpb24iLCJwcm9qZWN0aW9uIiwicG9zaXRpb24iLCJzaXplIiwiZGF0YSIsImNvbG9yIiwiZm92IiwibmVhciIsImZhciIsImFzcGVjdCIsInoiLCJwZXJzcGVjdGl2ZSIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImdsIiwiZ2V0Q29udGV4dCIsImNvdW50IiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVQcm9ncmFtIiwiY3JlYXRlQnVmZmVycyIsImNyZWF0ZVVuaWZvcm1zIiwidXBkYXRlQnVmZmVycyIsInVwZGF0ZVVuaWZvcm1zIiwiY3JlYXRlVGV4dHVyZSIsImVuYWJsZSIsIkJMRU5EIiwiQ1VMTF9GQUNFIiwiYmxlbmRGdW5jIiwiU1JDX0FMUEhBIiwiT05FIiwiREVQVEhfVEVTVCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicmVzaXplIiwidXBkYXRlIiwiYmluZCIsInN0YXJ0IiwicGVyZm9ybWFuY2UiLCJub3ciLCJvbGQiLCJ4IiwicGFnZVgiLCJ3aWR0aCIsInkiLCJwYWdlWSIsImhlaWdodCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZHBpIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInN0eWxlIiwidmlld3BvcnQiLCJjbGVhckNvbG9yIiwic2V0UHJvamVjdGlvbiIsImZvdlJhZCIsIk1hdGgiLCJQSSIsImYiLCJ0YW4iLCJyYW5nZUludiIsIm1hdHJpeCIsImNyZWF0ZVNoYWRlciIsInNvdXJjZSIsInNoYWRlciIsInNoYWRlclNvdXJjZSIsImNvbXBpbGVTaGFkZXIiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImNvbnNvbGUiLCJsb2ciLCJnZXRTaGFkZXJJbmZvTG9nIiwiZGVsZXRlU2hhZGVyIiwidmVydGV4U2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsImZyYWdtZW50U2hhZGVyIiwiRlJBR01FTlRfU0hBREVSIiwicHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwidXNlUHJvZ3JhbSIsImdldFByb2dyYW1JbmZvTG9nIiwiZGVsZXRlUHJvZ3JhbSIsInZhbHVlcyIsImtleXMiLCJmb3JFYWNoIiwibmFtZSIsInVuaWZvcm0iLCJsb2NhdGlvbiIsImdldFVuaWZvcm1Mb2NhdGlvbiIsImRlZmluZVByb3BlcnR5Iiwic2V0Iiwic2V0VW5pZm9ybSIsImdldCIsInVuaWZvcm0xaSIsInVuaWZvcm0xZiIsInVuaWZvcm0yZiIsInVuaWZvcm0zZiIsInVuaWZvcm00ZiIsInVuaWZvcm1NYXRyaXgyZnYiLCJ1bmlmb3JtTWF0cml4M2Z2IiwidW5pZm9ybU1hdHJpeDRmdiIsImJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsInNldEJ1ZmZlciIsImxlbmd0aCIsImluZGV4IiwiZ2V0QXR0cmliTG9jYXRpb24iLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiRkxPQVQiLCJidWZmZXJEYXRhIiwiRmxvYXQzMkFycmF5IiwiU1RBVElDX0RSQVciLCJzcmMiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJ0ZXhJbWFnZTJEIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJVaW50OEFycmF5IiwibG9hZFRleHR1cmUiLCJ0ZXh0dXJlSW1hZ2UiLCJJbWFnZSIsIm9ubG9hZCIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01JTl9GSUxURVIiLCJMSU5FQVIiLCJURVhUVVJFX01BR19GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsImVsYXBzZWQiLCJkZWx0YSIsImNsZWFyIiwiQ09MT1JCVUZGRVJCSVQiLCJkcmF3QXJyYXlzIiwiUE9JTlRTIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicG9pbnRTaXplIiwicXVlcnlTZWxlY3RvciIsImZpZWxkIiwic3BlZWQiLCJ3IiwiaCIsImRlcHRoIiwiZGlzdGFuY2UiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/waves.js\n");

/***/ })

});