"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/waves.js":
/*!**********************!*\
  !*** ./src/waves.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"waves\": function() { return /* binding */ waves; }\n/* harmony export */ });\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar waves = function() {\n    var ShaderProgram = /*#__PURE__*/ function() {\n        \"use strict\";\n        function ShaderProgram(holder) {\n            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            var _this = this;\n            _classCallCheck(this, ShaderProgram);\n            options = Object.assign({\n                antialias: false,\n                depthTest: false,\n                mousemove: false,\n                autosize: true,\n                side: \"front\",\n                vertex: \"\\n                   precision highp float;\\n           \\n                   attribute vec4 a_position;\\n                   attribute vec4 a_color;\\n           \\n                   uniform float u_time;\\n                   uniform vec2 u_resolution;\\n                   uniform vec2 u_mousemove;\\n                   uniform mat4 u_projection;\\n           \\n                   varying vec4 v_color;\\n           \\n                   void main() {\\n           \\n                     gl_Position = u_projection * a_position;\\n                     gl_PointSize = (10.0 / gl_Position.w) * 100.0;\\n           \\n                     v_color = a_color;\\n           \\n                   }\",\n                fragment: \"\\n                   precision highp float;\\n           \\n                   uniform sampler2D u_texture;\\n                   uniform int u_hasTexture;\\n           \\n                   varying vec4 v_color;\\n           \\n                   void main() {\\n           \\n                     if ( u_hasTexture == 1 ) {\\n           \\n                       gl_FragColor = v_color * texture2D(u_texture, gl_PointCoord);\\n           \\n                     } else {\\n           \\n                       gl_FragColor = v_color;\\n           \\n                     }\\n           \\n                   }\",\n                uniforms: {},\n                buffers: {},\n                camera: {},\n                texture: null,\n                onUpdate: function() {},\n                onResize: function() {}\n            }, options);\n            var uniforms = Object.assign({\n                time: {\n                    type: \"float\",\n                    value: 0\n                },\n                hasTexture: {\n                    type: \"int\",\n                    value: 0\n                },\n                resolution: {\n                    type: \"vec2\",\n                    value: [\n                        0,\n                        0\n                    ]\n                },\n                mousemove: {\n                    type: \"vec2\",\n                    value: [\n                        0,\n                        0\n                    ]\n                },\n                projection: {\n                    type: \"mat4\",\n                    value: [\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ]\n                }\n            }, options.uniforms);\n            var buffers = Object.assign({\n                position: {\n                    size: 3,\n                    data: []\n                },\n                color: {\n                    size: 4,\n                    data: []\n                }\n            }, options.buffers);\n            var camera = Object.assign({\n                fov: 60,\n                near: 1,\n                far: 10000,\n                aspect: 1,\n                z: 100,\n                perspective: true\n            }, options.camera);\n            var canvas = document.createElement(\"canvas\");\n            var gl = canvas.getContext(\"webgl\", {\n                antialias: options.antialias\n            });\n            if (!gl) return false;\n            this.count = 0;\n            this.gl = gl;\n            this.canvas = canvas;\n            this.camera = camera;\n            this.holder = holder;\n            this.onUpdate = options.onUpdate;\n            this.onResize = options.onResize;\n            this.data = {};\n            holder.appendChild(canvas);\n            this.createProgram(options.vertex, options.fragment);\n            this.createBuffers(buffers);\n            this.createUniforms(uniforms);\n            this.updateBuffers();\n            this.updateUniforms();\n            this.createTexture(options.texture);\n            gl.enable(gl.BLEND);\n            gl.enable(gl.CULL_FACE);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n            gl[options.depthTest ? \"enable\" : \"disable\"](gl.DEPTH_TEST);\n            if (options.autosize) window.addEventListener(\"resize\", function(e) {\n                return _this.resize(e);\n            }, false);\n            if (options.mousemove) window.addEventListener(\"mousemove\", function(e) {\n                return _this.mousemove(e);\n            }, false);\n            this.resize();\n            this.update = this.update.bind(this);\n            this.time = {\n                start: performance.now(),\n                old: performance.now()\n            };\n            this.update();\n        }\n        _createClass(ShaderProgram, [\n            {\n                key: \"mousemove\",\n                value: function mousemove(e) {\n                    var x = e.pageX / this.width * 2 - 1;\n                    var y = e.pageY / this.height * 2 - 1;\n                    this.uniforms.mousemove = [\n                        x,\n                        y\n                    ];\n                }\n            },\n            {\n                key: \"resize\",\n                value: function resize(e) {\n                    var holder = this.holder;\n                    var canvas = this.canvas;\n                    var gl = this.gl;\n                    var width = this.width = holder.offsetWidth;\n                    var height = this.height = holder.offsetHeight;\n                    var aspect = this.aspect = width / height;\n                    var dpi = devicePixelRatio;\n                    canvas.width = width * dpi;\n                    canvas.height = height * dpi;\n                    canvas.style.width = width + \"px\";\n                    canvas.style.height = height + \"px\";\n                    gl.viewport(0, 0, width * dpi, height * dpi);\n                    gl.clearColor(0, 0, 0, 0);\n                    this.uniforms.resolution = [\n                        width,\n                        height\n                    ];\n                    this.uniforms.projection = this.setProjection(aspect);\n                    this.onResize(width, height, dpi);\n                }\n            },\n            {\n                key: \"setProjection\",\n                value: function setProjection(aspect) {\n                    var camera = this.camera;\n                    if (camera.perspective) {\n                        camera.aspect = aspect;\n                        var fovRad = camera.fov * (Math.PI / 180);\n                        var f = Math.tan(Math.PI * 0.5 - 0.5 * fovRad);\n                        var rangeInv = 1.0 / (camera.near - camera.far);\n                        var matrix = [\n                            f / camera.aspect,\n                            0,\n                            0,\n                            0,\n                            0,\n                            f,\n                            0,\n                            0,\n                            0,\n                            0,\n                            (camera.near + camera.far) * rangeInv,\n                            -1,\n                            0,\n                            0,\n                            camera.near * camera.far * rangeInv * 2,\n                            0, \n                        ];\n                        matrix[14] += camera.z;\n                        matrix[15] += camera.z;\n                        return matrix;\n                    } else {\n                        return [\n                            2 / this.width,\n                            0,\n                            0,\n                            0,\n                            0,\n                            -2 / this.height,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            -1,\n                            1,\n                            0,\n                            1, \n                        ];\n                    }\n                }\n            },\n            {\n                key: \"createShader\",\n                value: function createShader(type, source) {\n                    var gl = this.gl;\n                    var shader = gl.createShader(type);\n                    gl.shaderSource(shader, source);\n                    gl.compileShader(shader);\n                    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                        return shader;\n                    } else {\n                        console.log(gl.getShaderInfoLog(shader));\n                        gl.deleteShader(shader);\n                    }\n                }\n            },\n            {\n                key: \"createProgram\",\n                value: function createProgram(vertex, fragment) {\n                    var gl = this.gl;\n                    var vertexShader = this.createShader(gl.VERTEX_SHADER, vertex);\n                    var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragment);\n                    var program = gl.createProgram();\n                    gl.attachShader(program, vertexShader);\n                    gl.attachShader(program, fragmentShader);\n                    gl.linkProgram(program);\n                    if (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                        gl.useProgram(program);\n                        this.program = program;\n                    } else {\n                        console.log(gl.getProgramInfoLog(program));\n                        gl.deleteProgram(program);\n                    }\n                }\n            },\n            {\n                key: \"createUniforms\",\n                value: function createUniforms(data) {\n                    var _this = this;\n                    var gl = this.gl;\n                    var uniforms = this.data.uniforms = data;\n                    var values = this.uniforms = {};\n                    Object.keys(uniforms).forEach(function(name) {\n                        var _this1 = _this;\n                        var uniform = uniforms[name];\n                        uniform.location = gl.getUniformLocation(_this.program, \"u_\" + name);\n                        Object.defineProperty(values, name, {\n                            set: function(value) {\n                                uniforms[name].value = value;\n                                _this1.setUniform(name, value);\n                            },\n                            get: function() {\n                                return uniforms[name].value;\n                            }\n                        });\n                    });\n                }\n            },\n            {\n                key: \"setUniform\",\n                value: function setUniform(name, value) {\n                    var gl = this.gl;\n                    var uniform = this.data.uniforms[name];\n                    uniform.value = value;\n                    switch(uniform.type){\n                        case \"int\":\n                            {\n                                gl.uniform1i(uniform.location, value);\n                                break;\n                            }\n                        case \"float\":\n                            {\n                                gl.uniform1f(uniform.location, value);\n                                break;\n                            }\n                        case \"vec2\":\n                            {\n                                var _gl;\n                                (_gl = gl).uniform2f.apply(_gl, [\n                                    uniform.location\n                                ].concat(_toConsumableArray(value)));\n                                break;\n                            }\n                        case \"vec3\":\n                            {\n                                var _gl1;\n                                (_gl1 = gl).uniform3f.apply(_gl1, [\n                                    uniform.location\n                                ].concat(_toConsumableArray(value)));\n                                break;\n                            }\n                        case \"vec4\":\n                            {\n                                var _gl2;\n                                (_gl2 = gl).uniform4f.apply(_gl2, [\n                                    uniform.location\n                                ].concat(_toConsumableArray(value)));\n                                break;\n                            }\n                        case \"mat2\":\n                            {\n                                gl.uniformMatrix2fv(uniform.location, false, value);\n                                break;\n                            }\n                        case \"mat3\":\n                            {\n                                gl.uniformMatrix3fv(uniform.location, false, value);\n                                break;\n                            }\n                        case \"mat4\":\n                            {\n                                gl.uniformMatrix4fv(uniform.location, false, value);\n                                break;\n                            }\n                    }\n                // ivec2       : uniform2i,\n                // ivec3       : uniform3i,\n                // ivec4       : uniform4i,\n                // sampler2D   : uniform1i,\n                // samplerCube : uniform1i,\n                // bool        : uniform1i,\n                // bvec2       : uniform2i,\n                // bvec3       : uniform3i,\n                // bvec4       : uniform4i,\n                }\n            },\n            {\n                key: \"updateUniforms\",\n                value: function updateUniforms() {\n                    var _this = this;\n                    var gl = this.gl;\n                    var uniforms = this.data.uniforms;\n                    Object.keys(uniforms).forEach(function(name) {\n                        var uniform = uniforms[name];\n                        _this.uniforms[name] = uniform.value;\n                    });\n                }\n            },\n            {\n                key: \"createBuffers\",\n                value: function createBuffers(data1) {\n                    var _this = this;\n                    var gl = this.gl;\n                    var buffers = this.data.buffers = data1;\n                    var values = this.buffers = {};\n                    Object.keys(buffers).forEach(function(name) {\n                        var _this2 = _this;\n                        var buffer = buffers[name];\n                        buffer.buffer = _this.createBuffer(\"a_\" + name, buffer.size);\n                        Object.defineProperty(values, name, {\n                            set: function(data) {\n                                buffers[name].data = data;\n                                _this2.setBuffer(name, data);\n                                if (name == \"position\") _this2.count = buffers.position.data.length / 3;\n                            },\n                            get: function() {\n                                return buffers[name].data;\n                            }\n                        });\n                    });\n                }\n            },\n            {\n                key: \"createBuffer\",\n                value: function createBuffer(name, size) {\n                    var gl = this.gl;\n                    var program = this.program;\n                    var index = gl.getAttribLocation(program, name);\n                    var buffer = gl.createBuffer();\n                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n                    gl.enableVertexAttribArray(index);\n                    gl.vertexAttribPointer(index, size, gl.FLOAT, false, 0, 0);\n                    return buffer;\n                }\n            },\n            {\n                key: \"setBuffer\",\n                value: function setBuffer(name, data) {\n                    var gl = this.gl;\n                    var buffers = this.data.buffers;\n                    if (name == null && !gl.bindBuffer(gl.ARRAY_BUFFER, null)) return;\n                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers[name].buffer);\n                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\n                }\n            },\n            {\n                key: \"updateBuffers\",\n                value: function updateBuffers() {\n                    var gl = this.gl;\n                    var buffers = this.buffers;\n                    Object.keys(buffers).forEach(function(name) {\n                        return buffers[name] = buffer.data;\n                    });\n                    this.setBuffer(null);\n                }\n            },\n            {\n                key: \"createTexture\",\n                value: function createTexture(src) {\n                    var gl = this.gl;\n                    var texture = gl.createTexture();\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([\n                        0,\n                        0,\n                        0,\n                        0\n                    ]));\n                    this.texture = texture;\n                    if (src) {\n                        this.uniforms.hasTexture = 1;\n                        this.loadTexture(src);\n                    }\n                }\n            },\n            {\n                key: \"loadTexture\",\n                value: function loadTexture(src) {\n                    var gl = this.gl;\n                    var texture = this.texture;\n                    var textureImage = new Image();\n                    textureImage.onload = function() {\n                        gl.bindTexture(gl.TEXTURE_2D, texture);\n                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    };\n                    textureImage.src = src;\n                }\n            },\n            {\n                key: \"update\",\n                value: function update() {\n                    var gl = this.gl;\n                    var now = performance.now();\n                    var elapsed = (now - this.time.start) / 5000;\n                    var delta = now - this.time.old;\n                    this.time.old = now;\n                    this.uniforms.time = elapsed;\n                    if (this.count > 0) {\n                        gl.clear(gl.COLORBUFFERBIT);\n                        gl.drawArrays(gl.POINTS, 0, this.count);\n                    }\n                    this.onUpdate(delta);\n                    requestAnimationFrame(this.update);\n                }\n            }\n        ]);\n        return ShaderProgram;\n    }();\n    var pointSize = 2.5;\n    var waves = new ShaderProgram(document.querySelector(\".waves\"), {\n        texture: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAb1BMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8v0wLRAAAAJHRSTlMAC/goGvDhmwcExrVjWzrm29TRqqSKenRXVklANSIUE8mRkGpv+HOfAAABCElEQVQ4y4VT13LDMAwLrUHteO+R9f/fWMfO6dLaPeKVEECRxOULWsEGpS9nULDwia2Y+ALqUNbAWeg775zv+sA4/FFRMxt8U2FZFCVWjR/YrH4/H9sarclSKdPMWKzb8VsEeHB3m0shkhVCyNzeXeAQ9Xl4opEieX2QCGnwGbj6GMyjw9t1K0fK9YZunPXeAGsfJtYjwzxaBnozGGorYz0ypK2HzQSYx1y8DgSRo2ewOiyh2QWOEk1Y9OrQV0a8TiBM1a8eMHWYnRMy7CZ4t1CmyRkhSUvP3gRXyHOCLBxNoC3IJv//ZrJ/kxxUHPUB+6jJZZHrpg6GOjnqaOmzp4NDR48OLxn/H27SRQ08S0ZJAAAAAElFTkSuQmCC\",\n        uniforms: {\n            size: {\n                type: \"float\",\n                value: pointSize\n            },\n            field: {\n                type: \"vec3\",\n                value: [\n                    0,\n                    0,\n                    0\n                ]\n            },\n            speed: {\n                type: \"float\",\n                value: 5\n            }\n        },\n        vertex: \"\\n               #define M_PI 3.1415926535897932384626433832795\\n           \\n               precision highp float;\\n           \\n               attribute vec4 a_position;\\n               attribute vec4 a_color;\\n           \\n               uniform float u_time;\\n               uniform float u_size;\\n               uniform float u_speed;\\n               uniform vec3 u_field;\\n               uniform mat4 u_projection;\\n           \\n               varying vec4 v_color;\\n           \\n               void main() {\\n           \\n                 vec3 pos = a_position.xyz;\\n           \\n                 pos.y += (\\n                   cos(pos.x / u_field.x * M_PI * 8.0 + u_time * u_speed) +\\n                   sin(pos.z / u_field.z * M_PI * 8.0 + u_time * u_speed)\\n                 ) * u_field.y;\\n           \\n                 gl_Position = u_projection * vec4( pos.xyz, a_position.w );\\n                 gl_PointSize = ( u_size / gl_Position.w ) * 100.0;\\n           \\n                 v_color = a_color;\\n           \\n               }\",\n        fragment: \"\\n               precision highp float;\\n           \\n               uniform sampler2D u_texture;\\n           \\n               varying vec4 v_color;\\n           \\n               void main() {\\n           \\n                 gl_FragColor = v_color * texture2D(u_texture, gl_PointCoord);\\n           \\n               }\",\n        onResize: function onResize(w, h, dpi) {\n            var position = [], color = [];\n            var width = 400 * (w / h);\n            var depth = 400;\n            var height = 3;\n            var distance = 5;\n            for(var x = 0; x < width; x += distance){\n                for(var z = 0; z < depth; z += distance){\n                    position.push(-width / 2 + x, -30, -depth / 2 + z);\n                    color.push(\"red\");\n                }\n            }\n            this.uniforms.field = [\n                width,\n                height,\n                depth\n            ];\n            this.buffers.position = position;\n            this.buffers.color = color;\n            this.uniforms.size = h / 400 * pointSize * dpi;\n        }\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcsQ0FBQyxHQUFHNUksQ0FBQyxDQUFDLENBQUM7b0JBQ25ETCxLQUFLLENBQUNtSixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBRW5CO2FBQ0Y7WUFFRCxJQUFJLENBQUNsSyxRQUFRLENBQUM0SixLQUFLLEdBQUc7Z0JBQUN0RyxLQUFLO2dCQUFFRyxNQUFNO2dCQUFFdUcsS0FBSzthQUFDLENBQUM7WUFFN0MsSUFBSSxDQUFDL0osT0FBTyxDQUFDVyxRQUFRLEdBQUdBLFFBQVEsQ0FBQztZQUNqQyxJQUFJLENBQUNYLE9BQU8sQ0FBQ2MsS0FBSyxHQUFHQSxLQUFLLENBQUM7WUFFM0IsSUFBSSxDQUFDZixRQUFRLENBQUNhLElBQUksR0FBRyxDQUFFLEdBQUcsR0FBRyxHQUFJNkksU0FBUyxHQUFHOUYsR0FBRyxDQUFDO1NBQ2xEO0tBQ0YsQ0FBQztDQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3dhdmVzLmpzPzcwN2MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHdhdmVzID0gKCkgPT4ge1xyXG4gIGNsYXNzIFNoYWRlclByb2dyYW0ge1xyXG4gICAgY29uc3RydWN0b3IoaG9sZGVyLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcclxuICAgICAgICAgIGRlcHRoVGVzdDogZmFsc2UsXHJcbiAgICAgICAgICBtb3VzZW1vdmU6IGZhbHNlLFxyXG4gICAgICAgICAgYXV0b3NpemU6IHRydWUsXHJcbiAgICAgICAgICBzaWRlOiBcImZyb250XCIsXHJcbiAgICAgICAgICB2ZXJ0ZXg6IGBcclxuICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X3RpbWU7XHJcbiAgICAgICAgICAgICAgICAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIHVfbW91c2Vtb3ZlO1xyXG4gICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfcHJvamVjdGlvbiAqIGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgIGdsX1BvaW50U2l6ZSA9ICgxMC4wIC8gZ2xfUG9zaXRpb24udykgKiAxMDAuMDtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgdl9jb2xvciA9IGFfY29sb3I7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICB9YCxcclxuICAgICAgICAgIGZyYWdtZW50OiBgXHJcbiAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICB1bmlmb3JtIGludCB1X2hhc1RleHR1cmU7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgaWYgKCB1X2hhc1RleHR1cmUgPT0gMSApIHtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yICogdGV4dHVyZTJEKHVfdGV4dHVyZSwgZ2xfUG9pbnRDb29yZCk7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgfWAsXHJcbiAgICAgICAgICB1bmlmb3Jtczoge30sXHJcbiAgICAgICAgICBidWZmZXJzOiB7fSxcclxuICAgICAgICAgIGNhbWVyYToge30sXHJcbiAgICAgICAgICB0ZXh0dXJlOiBudWxsLFxyXG4gICAgICAgICAgb25VcGRhdGU6ICgpID0+IHt9LFxyXG4gICAgICAgICAgb25SZXNpemU6ICgpID0+IHt9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3B0aW9uc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgdW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHRpbWU6IHsgdHlwZTogXCJmbG9hdFwiLCB2YWx1ZTogMCB9LFxyXG4gICAgICAgICAgaGFzVGV4dHVyZTogeyB0eXBlOiBcImludFwiLCB2YWx1ZTogMCB9LFxyXG4gICAgICAgICAgcmVzb2x1dGlvbjogeyB0eXBlOiBcInZlYzJcIiwgdmFsdWU6IFswLCAwXSB9LFxyXG4gICAgICAgICAgbW91c2Vtb3ZlOiB7IHR5cGU6IFwidmVjMlwiLCB2YWx1ZTogWzAsIDBdIH0sXHJcbiAgICAgICAgICBwcm9qZWN0aW9uOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwibWF0NFwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9wdGlvbnMudW5pZm9ybXNcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBPYmplY3QuYXNzaWduKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHBvc2l0aW9uOiB7IHNpemU6IDMsIGRhdGE6IFtdIH0sXHJcbiAgICAgICAgICBjb2xvcjogeyBzaXplOiA0LCBkYXRhOiBbXSB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3B0aW9ucy5idWZmZXJzXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBjYW1lcmEgPSBPYmplY3QuYXNzaWduKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGZvdjogNjAsXHJcbiAgICAgICAgICBuZWFyOiAxLFxyXG4gICAgICAgICAgZmFyOiAxMDAwMCxcclxuICAgICAgICAgIGFzcGVjdDogMSxcclxuICAgICAgICAgIHo6IDEwMCxcclxuICAgICAgICAgIHBlcnNwZWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3B0aW9ucy5jYW1lcmFcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCB7IGFudGlhbGlhczogb3B0aW9ucy5hbnRpYWxpYXMgfSk7XHJcblxyXG4gICAgICBpZiAoIWdsKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcclxuICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgIHRoaXMuaG9sZGVyID0gaG9sZGVyO1xyXG4gICAgICB0aGlzLm9uVXBkYXRlID0gb3B0aW9ucy5vblVwZGF0ZTtcclxuICAgICAgdGhpcy5vblJlc2l6ZSA9IG9wdGlvbnMub25SZXNpemU7XHJcbiAgICAgIHRoaXMuZGF0YSA9IHt9O1xyXG5cclxuICAgICAgaG9sZGVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XHJcblxyXG4gICAgICB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy52ZXJ0ZXgsIG9wdGlvbnMuZnJhZ21lbnQpO1xyXG5cclxuICAgICAgdGhpcy5jcmVhdGVCdWZmZXJzKGJ1ZmZlcnMpO1xyXG4gICAgICB0aGlzLmNyZWF0ZVVuaWZvcm1zKHVuaWZvcm1zKTtcclxuXHJcbiAgICAgIHRoaXMudXBkYXRlQnVmZmVycygpO1xyXG4gICAgICB0aGlzLnVwZGF0ZVVuaWZvcm1zKCk7XHJcblxyXG4gICAgICB0aGlzLmNyZWF0ZVRleHR1cmUob3B0aW9ucy50ZXh0dXJlKTtcclxuXHJcbiAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpO1xyXG4gICAgICBnbFtvcHRpb25zLmRlcHRoVGVzdCA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIl0oZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5hdXRvc2l6ZSlcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoZSkgPT4gdGhpcy5yZXNpemUoZSksIGZhbHNlKTtcclxuICAgICAgaWYgKG9wdGlvbnMubW91c2Vtb3ZlKVxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIChlKSA9PiB0aGlzLm1vdXNlbW92ZShlKSwgZmFsc2UpO1xyXG5cclxuICAgICAgdGhpcy5yZXNpemUoKTtcclxuXHJcbiAgICAgIHRoaXMudXBkYXRlID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKTtcclxuICAgICAgdGhpcy50aW1lID0geyBzdGFydDogcGVyZm9ybWFuY2Uubm93KCksIG9sZDogcGVyZm9ybWFuY2Uubm93KCkgfTtcclxuICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBtb3VzZW1vdmUoZSkge1xyXG4gICAgICBsZXQgeCA9IChlLnBhZ2VYIC8gdGhpcy53aWR0aCkgKiAyIC0gMTtcclxuICAgICAgbGV0IHkgPSAoZS5wYWdlWSAvIHRoaXMuaGVpZ2h0KSAqIDIgLSAxO1xyXG5cclxuICAgICAgdGhpcy51bmlmb3Jtcy5tb3VzZW1vdmUgPSBbeCwgeV07XHJcbiAgICB9XHJcblxyXG4gICAgcmVzaXplKGUpIHtcclxuICAgICAgY29uc3QgaG9sZGVyID0gdGhpcy5ob2xkZXI7XHJcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICBjb25zdCB3aWR0aCA9ICh0aGlzLndpZHRoID0gaG9sZGVyLm9mZnNldFdpZHRoKTtcclxuICAgICAgY29uc3QgaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0ID0gaG9sZGVyLm9mZnNldEhlaWdodCk7XHJcbiAgICAgIGNvbnN0IGFzcGVjdCA9ICh0aGlzLmFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0KTtcclxuICAgICAgY29uc3QgZHBpID0gZGV2aWNlUGl4ZWxSYXRpbztcclxuXHJcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHBpO1xyXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHBpO1xyXG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcclxuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcclxuXHJcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoICogZHBpLCBoZWlnaHQgKiBkcGkpO1xyXG4gICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xyXG5cclxuICAgICAgdGhpcy51bmlmb3Jtcy5yZXNvbHV0aW9uID0gW3dpZHRoLCBoZWlnaHRdO1xyXG4gICAgICB0aGlzLnVuaWZvcm1zLnByb2plY3Rpb24gPSB0aGlzLnNldFByb2plY3Rpb24oYXNwZWN0KTtcclxuXHJcbiAgICAgIHRoaXMub25SZXNpemUod2lkdGgsIGhlaWdodCwgZHBpKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRQcm9qZWN0aW9uKGFzcGVjdCkge1xyXG4gICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcclxuXHJcbiAgICAgIGlmIChjYW1lcmEucGVyc3BlY3RpdmUpIHtcclxuICAgICAgICBjYW1lcmEuYXNwZWN0ID0gYXNwZWN0O1xyXG5cclxuICAgICAgICBjb25zdCBmb3ZSYWQgPSBjYW1lcmEuZm92ICogKE1hdGguUEkgLyAxODApO1xyXG4gICAgICAgIGNvbnN0IGYgPSBNYXRoLnRhbihNYXRoLlBJICogMC41IC0gMC41ICogZm92UmFkKTtcclxuICAgICAgICBjb25zdCByYW5nZUludiA9IDEuMCAvIChjYW1lcmEubmVhciAtIGNhbWVyYS5mYXIpO1xyXG5cclxuICAgICAgICBjb25zdCBtYXRyaXggPSBbXHJcbiAgICAgICAgICBmIC8gY2FtZXJhLmFzcGVjdCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICBmLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIChjYW1lcmEubmVhciArIGNhbWVyYS5mYXIpICogcmFuZ2VJbnYsXHJcbiAgICAgICAgICAtMSxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgY2FtZXJhLm5lYXIgKiBjYW1lcmEuZmFyICogcmFuZ2VJbnYgKiAyLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBtYXRyaXhbMTRdICs9IGNhbWVyYS56O1xyXG4gICAgICAgIG1hdHJpeFsxNV0gKz0gY2FtZXJhLno7XHJcblxyXG4gICAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgIDIgLyB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIC0yIC8gdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMSxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAtMSxcclxuICAgICAgICAgIDEsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMSxcclxuICAgICAgICBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlU2hhZGVyKHR5cGUsIHNvdXJjZSkge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcclxuXHJcbiAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XHJcbiAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuXHJcbiAgICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XHJcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVQcm9ncmFtKHZlcnRleCwgZnJhZ21lbnQpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgY29uc3QgdmVydGV4U2hhZGVyID0gdGhpcy5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4KTtcclxuICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50KTtcclxuXHJcbiAgICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcclxuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG4gICAgICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xyXG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVVbmlmb3JtcyhkYXRhKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgY29uc3QgdW5pZm9ybXMgPSAodGhpcy5kYXRhLnVuaWZvcm1zID0gZGF0YSk7XHJcbiAgICAgIGNvbnN0IHZhbHVlcyA9ICh0aGlzLnVuaWZvcm1zID0ge30pO1xyXG5cclxuICAgICAgT2JqZWN0LmtleXModW5pZm9ybXMpLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICBjb25zdCB1bmlmb3JtID0gdW5pZm9ybXNbbmFtZV07XHJcblxyXG4gICAgICAgIHVuaWZvcm0ubG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfXCIgKyBuYW1lKTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlcywgbmFtZSwge1xyXG4gICAgICAgICAgc2V0OiAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdW5pZm9ybXNbbmFtZV0udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBnZXQ6ICgpID0+IHVuaWZvcm1zW25hbWVdLnZhbHVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRVbmlmb3JtKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgY29uc3QgdW5pZm9ybSA9IHRoaXMuZGF0YS51bmlmb3Jtc1tuYW1lXTtcclxuXHJcbiAgICAgIHVuaWZvcm0udmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICAgIHN3aXRjaCAodW5pZm9ybS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcImludFwiOiB7XHJcbiAgICAgICAgICBnbC51bmlmb3JtMWkodW5pZm9ybS5sb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJmbG9hdFwiOiB7XHJcbiAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybS5sb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJ2ZWMyXCI6IHtcclxuICAgICAgICAgIGdsLnVuaWZvcm0yZih1bmlmb3JtLmxvY2F0aW9uLCAuLi52YWx1ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcInZlYzNcIjoge1xyXG4gICAgICAgICAgZ2wudW5pZm9ybTNmKHVuaWZvcm0ubG9jYXRpb24sIC4uLnZhbHVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwidmVjNFwiOiB7XHJcbiAgICAgICAgICBnbC51bmlmb3JtNGYodW5pZm9ybS5sb2NhdGlvbiwgLi4udmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJtYXQyXCI6IHtcclxuICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYodW5pZm9ybS5sb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwibWF0M1wiOiB7XHJcbiAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVuaWZvcm0ubG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIm1hdDRcIjoge1xyXG4gICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih1bmlmb3JtLmxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpdmVjMiAgICAgICA6IHVuaWZvcm0yaSxcclxuICAgICAgLy8gaXZlYzMgICAgICAgOiB1bmlmb3JtM2ksXHJcbiAgICAgIC8vIGl2ZWM0ICAgICAgIDogdW5pZm9ybTRpLFxyXG4gICAgICAvLyBzYW1wbGVyMkQgICA6IHVuaWZvcm0xaSxcclxuICAgICAgLy8gc2FtcGxlckN1YmUgOiB1bmlmb3JtMWksXHJcbiAgICAgIC8vIGJvb2wgICAgICAgIDogdW5pZm9ybTFpLFxyXG4gICAgICAvLyBidmVjMiAgICAgICA6IHVuaWZvcm0yaSxcclxuICAgICAgLy8gYnZlYzMgICAgICAgOiB1bmlmb3JtM2ksXHJcbiAgICAgIC8vIGJ2ZWM0ICAgICAgIDogdW5pZm9ybTRpLFxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVVuaWZvcm1zKCkge1xyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy5kYXRhLnVuaWZvcm1zO1xyXG5cclxuICAgICAgT2JqZWN0LmtleXModW5pZm9ybXMpLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICBjb25zdCB1bmlmb3JtID0gdW5pZm9ybXNbbmFtZV07XHJcblxyXG4gICAgICAgIHRoaXMudW5pZm9ybXNbbmFtZV0gPSB1bmlmb3JtLnZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVCdWZmZXJzKGRhdGEpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICBjb25zdCBidWZmZXJzID0gKHRoaXMuZGF0YS5idWZmZXJzID0gZGF0YSk7XHJcbiAgICAgIGNvbnN0IHZhbHVlcyA9ICh0aGlzLmJ1ZmZlcnMgPSB7fSk7XHJcblxyXG4gICAgICBPYmplY3Qua2V5cyhidWZmZXJzKS5mb3JFYWNoKChuYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tuYW1lXTtcclxuXHJcbiAgICAgICAgYnVmZmVyLmJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKFwiYV9cIiArIG5hbWUsIGJ1ZmZlci5zaXplKTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlcywgbmFtZSwge1xyXG4gICAgICAgICAgc2V0OiAoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBidWZmZXJzW25hbWVdLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihuYW1lLCBkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwicG9zaXRpb25cIilcclxuICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gYnVmZmVycy5wb3NpdGlvbi5kYXRhLmxlbmd0aCAvIDM7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZ2V0OiAoKSA9PiBidWZmZXJzW25hbWVdLmRhdGEsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUJ1ZmZlcihuYW1lLCBzaXplKSB7XHJcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbTtcclxuXHJcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSk7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgc2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuXHJcbiAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0QnVmZmVyKG5hbWUsIGRhdGEpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICBjb25zdCBidWZmZXJzID0gdGhpcy5kYXRhLmJ1ZmZlcnM7XHJcblxyXG4gICAgICBpZiAobmFtZSA9PSBudWxsICYmICFnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCkpIHJldHVybjtcclxuXHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzW25hbWVdLmJ1ZmZlcik7XHJcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KGRhdGEpLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlQnVmZmVycygpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICBjb25zdCBidWZmZXJzID0gdGhpcy5idWZmZXJzO1xyXG5cclxuICAgICAgT2JqZWN0LmtleXMoYnVmZmVycykuZm9yRWFjaCgobmFtZSkgPT4gKGJ1ZmZlcnNbbmFtZV0gPSBidWZmZXIuZGF0YSkpO1xyXG5cclxuICAgICAgdGhpcy5zZXRCdWZmZXIobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlVGV4dHVyZShzcmMpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICAgIGdsLnRleEltYWdlMkQoXHJcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcclxuICAgICAgICAwLFxyXG4gICAgICAgIGdsLlJHQkEsXHJcbiAgICAgICAgMSxcclxuICAgICAgICAxLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgZ2wuUkdCQSxcclxuICAgICAgICBnbC5VTlNJR05FRF9CWVRFLFxyXG4gICAgICAgIG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwXSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XHJcblxyXG4gICAgICBpZiAoc3JjKSB7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5oYXNUZXh0dXJlID0gMTtcclxuICAgICAgICB0aGlzLmxvYWRUZXh0dXJlKHNyYyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsb2FkVGV4dHVyZShzcmMpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xyXG5cclxuICAgICAgY29uc3QgdGV4dHVyZUltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgICB0ZXh0dXJlSW1hZ2Uub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cclxuICAgICAgICBnbC50ZXhJbWFnZTJEKFxyXG4gICAgICAgICAgZ2wuVEVYVFVSRV8yRCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgICAgZ2wuUkdCQSxcclxuICAgICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsXHJcbiAgICAgICAgICB0ZXh0dXJlSW1hZ2VcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuXHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0ZXh0dXJlSW1hZ2Uuc3JjID0gc3JjO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSAobm93IC0gdGhpcy50aW1lLnN0YXJ0KSAvIDUwMDA7XHJcbiAgICAgIGNvbnN0IGRlbHRhID0gbm93IC0gdGhpcy50aW1lLm9sZDtcclxuICAgICAgdGhpcy50aW1lLm9sZCA9IG5vdztcclxuXHJcbiAgICAgIHRoaXMudW5pZm9ybXMudGltZSA9IGVsYXBzZWQ7XHJcblxyXG4gICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUkJVRkZFUkJJVCk7XHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIHRoaXMuY291bnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLm9uVXBkYXRlKGRlbHRhKTtcclxuXHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBwb2ludFNpemUgPSAyLjU7XHJcblxyXG4gIGNvbnN0IHdhdmVzID0gbmV3IFNoYWRlclByb2dyYW0oZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi53YXZlc1wiKSwge1xyXG4gICAgdGV4dHVyZTpcclxuICAgICAgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQU1BQUFCRXBJckdBQUFBYjFCTVZFVUFBQUQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzh2MHdMUkFBQUFKSFJTVGxNQUMvZ29HdkRobXdjRXhyVmpXenJtMjlUUnFxU0tlblJYVmtsQU5TSVVFOG1Sa0dwditIT2ZBQUFCQ0VsRVFWUTR5NFZUMTNMRE1Bd0xyVUh0ZU8rUjlmL2ZXTWZPNmRMYVBlS1ZFRUNSeE9VTFdzRUdwUzluVUxEd2lhMlkrQUxxVU5iQVdlZzc3NXp2K3NBNC9GRlJNeHQ4VTJGWkZDVldqUi9Zckg0L0g5c2FyY2xTS2RQTVdLemI4VnNFZUhCM20wc2hraFZDeU56ZVhlQVE5WGw0b3BFaWVYMlFDR253R2JqNkdNeWp3OXQxSzBmSzlZWnVuUFhlQUdzZkp0WWp3enhhQm5vekdHb3JZejB5cEsySHpRU1l4MXk4RGdTUm8yZXdPaXloMlFXT0VrMVk5T3JRVjBhOFRpQk0xYThlTUhXWW5STXk3Q1o0dDFDbXlSa2hTVXZQM2dSWHlIT0NMQnhOb0MzSUp2Ly9ackova3h4VUhQVUIrNmpKWlpIcnBnNkdPam5xYU9tenA0TkRSNDhPTHhuL0gyN1NSUTA4UzBaSkFBQUFBRWxGVGtTdVFtQ0NcIixcclxuICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgIHNpemU6IHsgdHlwZTogXCJmbG9hdFwiLCB2YWx1ZTogcG9pbnRTaXplIH0sXHJcbiAgICAgIGZpZWxkOiB7IHR5cGU6IFwidmVjM1wiLCB2YWx1ZTogWzAsIDAsIDBdIH0sXHJcbiAgICAgIHNwZWVkOiB7IHR5cGU6IFwiZmxvYXRcIiwgdmFsdWU6IDUgfSxcclxuICAgIH0sXHJcbiAgICB2ZXJ0ZXg6IGBcclxuICAgICAgICAgICAgICAgI2RlZmluZSBNX1BJIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NVxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdV90aW1lO1xyXG4gICAgICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVfc2l6ZTtcclxuICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X3NwZWVkO1xyXG4gICAgICAgICAgICAgICB1bmlmb3JtIHZlYzMgdV9maWVsZDtcclxuICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHZfY29sb3I7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICB2ZWMzIHBvcyA9IGFfcG9zaXRpb24ueHl6O1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgIHBvcy55ICs9IChcclxuICAgICAgICAgICAgICAgICAgIGNvcyhwb3MueCAvIHVfZmllbGQueCAqIE1fUEkgKiA4LjAgKyB1X3RpbWUgKiB1X3NwZWVkKSArXHJcbiAgICAgICAgICAgICAgICAgICBzaW4ocG9zLnogLyB1X2ZpZWxkLnogKiBNX1BJICogOC4wICsgdV90aW1lICogdV9zcGVlZClcclxuICAgICAgICAgICAgICAgICApICogdV9maWVsZC55O1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogdmVjNCggcG9zLnh5eiwgYV9wb3NpdGlvbi53ICk7XHJcbiAgICAgICAgICAgICAgICAgZ2xfUG9pbnRTaXplID0gKCB1X3NpemUgLyBnbF9Qb3NpdGlvbi53ICkgKiAxMDAuMDtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICB2X2NvbG9yID0gYV9jb2xvcjtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgfWAsXHJcbiAgICBmcmFnbWVudDogYFxyXG4gICAgICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHZfY29sb3I7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yICogdGV4dHVyZTJEKHVfdGV4dHVyZSwgZ2xfUG9pbnRDb29yZCk7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIH1gLFxyXG4gICAgb25SZXNpemUodywgaCwgZHBpKSB7XHJcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gW10sXHJcbiAgICAgICAgY29sb3IgPSBbXTtcclxuXHJcbiAgICAgIGNvbnN0IHdpZHRoID0gNDAwICogKHcgLyBoKTtcclxuICAgICAgY29uc3QgZGVwdGggPSA0MDA7XHJcbiAgICAgIGNvbnN0IGhlaWdodCA9IDM7XHJcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gNTtcclxuXHJcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHggKz0gZGlzdGFuY2UpIHtcclxuICAgICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IGRlcHRoOyB6ICs9IGRpc3RhbmNlKSB7XHJcbiAgICAgICAgICBwb3NpdGlvbi5wdXNoKC13aWR0aCAvIDIgKyB4LCAtMzAsIC1kZXB0aCAvIDIgKyB6KTtcclxuICAgICAgICAgIGNvbG9yLnB1c2goXCJyZWRcIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy51bmlmb3Jtcy5maWVsZCA9IFt3aWR0aCwgaGVpZ2h0LCBkZXB0aF07XHJcblxyXG4gICAgICB0aGlzLmJ1ZmZlcnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgdGhpcy5idWZmZXJzLmNvbG9yID0gY29sb3I7XHJcblxyXG4gICAgICB0aGlzLnVuaWZvcm1zLnNpemUgPSAoaCAvIDQwMCkgKiBwb2ludFNpemUgKiBkcGk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG59O1xyXG4iXSwibmFtZXMiOlsid2F2ZXMiLCJTaGFkZXJQcm9ncmFtIiwiaG9sZGVyIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsImFudGlhbGlhcyIsImRlcHRoVGVzdCIsIm1vdXNlbW92ZSIsImF1dG9zaXplIiwic2lkZSIsInZlcnRleCIsImZyYWdtZW50IiwidW5pZm9ybXMiLCJidWZmZXJzIiwiY2FtZXJhIiwidGV4dHVyZSIsIm9uVXBkYXRlIiwib25SZXNpemUiLCJ0aW1lIiwidHlwZSIsInZhbHVlIiwiaGFzVGV4dHVyZSIsInJlc29sdXRpb24iLCJwcm9qZWN0aW9uIiwicG9zaXRpb24iLCJzaXplIiwiZGF0YSIsImNvbG9yIiwiZm92IiwibmVhciIsImZhciIsImFzcGVjdCIsInoiLCJwZXJzcGVjdGl2ZSIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImdsIiwiZ2V0Q29udGV4dCIsImNvdW50IiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVQcm9ncmFtIiwiY3JlYXRlQnVmZmVycyIsImNyZWF0ZVVuaWZvcm1zIiwidXBkYXRlQnVmZmVycyIsInVwZGF0ZVVuaWZvcm1zIiwiY3JlYXRlVGV4dHVyZSIsImVuYWJsZSIsIkJMRU5EIiwiQ1VMTF9GQUNFIiwiYmxlbmRGdW5jIiwiU1JDX0FMUEhBIiwiT05FIiwiREVQVEhfVEVTVCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicmVzaXplIiwidXBkYXRlIiwiYmluZCIsInN0YXJ0IiwicGVyZm9ybWFuY2UiLCJub3ciLCJvbGQiLCJ4IiwicGFnZVgiLCJ3aWR0aCIsInkiLCJwYWdlWSIsImhlaWdodCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZHBpIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInN0eWxlIiwidmlld3BvcnQiLCJjbGVhckNvbG9yIiwic2V0UHJvamVjdGlvbiIsImZvdlJhZCIsIk1hdGgiLCJQSSIsImYiLCJ0YW4iLCJyYW5nZUludiIsIm1hdHJpeCIsImNyZWF0ZVNoYWRlciIsInNvdXJjZSIsInNoYWRlciIsInNoYWRlclNvdXJjZSIsImNvbXBpbGVTaGFkZXIiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImNvbnNvbGUiLCJsb2ciLCJnZXRTaGFkZXJJbmZvTG9nIiwiZGVsZXRlU2hhZGVyIiwidmVydGV4U2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsImZyYWdtZW50U2hhZGVyIiwiRlJBR01FTlRfU0hBREVSIiwicHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwidXNlUHJvZ3JhbSIsImdldFByb2dyYW1JbmZvTG9nIiwiZGVsZXRlUHJvZ3JhbSIsInZhbHVlcyIsImtleXMiLCJmb3JFYWNoIiwibmFtZSIsInVuaWZvcm0iLCJsb2NhdGlvbiIsImdldFVuaWZvcm1Mb2NhdGlvbiIsImRlZmluZVByb3BlcnR5Iiwic2V0Iiwic2V0VW5pZm9ybSIsImdldCIsInVuaWZvcm0xaSIsInVuaWZvcm0xZiIsInVuaWZvcm0yZiIsInVuaWZvcm0zZiIsInVuaWZvcm00ZiIsInVuaWZvcm1NYXRyaXgyZnYiLCJ1bmlmb3JtTWF0cml4M2Z2IiwidW5pZm9ybU1hdHJpeDRmdiIsImJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsInNldEJ1ZmZlciIsImxlbmd0aCIsImluZGV4IiwiZ2V0QXR0cmliTG9jYXRpb24iLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiRkxPQVQiLCJidWZmZXJEYXRhIiwiRmxvYXQzMkFycmF5IiwiU1RBVElDX0RSQVciLCJzcmMiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJ0ZXhJbWFnZTJEIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJVaW50OEFycmF5IiwibG9hZFRleHR1cmUiLCJ0ZXh0dXJlSW1hZ2UiLCJJbWFnZSIsIm9ubG9hZCIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01JTl9GSUxURVIiLCJMSU5FQVIiLCJURVhUVVJFX01BR19GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsImVsYXBzZWQiLCJkZWx0YSIsImNsZWFyIiwiQ09MT1JCVUZGRVJCSVQiLCJkcmF3QXJyYXlzIiwiUE9JTlRTIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicG9pbnRTaXplIiwicXVlcnlTZWxlY3RvciIsImZpZWxkIiwic3BlZWQiLCJ3IiwiaCIsImRlcHRoIiwiZGlzdGFuY2UiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/waves.js\n");

/***/ })

});